<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - multi_draw</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
	<style>
		#info {
			background-color: rgba(0,0,0,0.75);
		}

		.dg .folder .gui-stats {
			height: auto;
		}
	</style>
</head>
<body>

	<div id="info">

		<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - multidraw

	</div>

	<div id="container"></div>

	<script type="module">
		import * as THREE from '../build/three.module.js';

		import Stats from './jsm/libs/stats.module.js';
		import { GUI } from './jsm/libs/dat.gui.module.js';

		import { OrbitControls } from './jsm/controls/OrbitControls.js';
		import * as BufferGeometryUtils from './jsm/utils/BufferGeometryUtils.js';

		let container, stats, gui, guiStatsEl;
		let camera, controls, scene, renderer;
		let geometries, mesh;

		const MAX_GEOMETRY_COUNT = 4096;

		const Method = {
			BATCHED: 'BATCHED',
			NAIVE: 'NAIVE'
		};

		const api = {
			method: Method.BATCHED,
			count: 256,
			frustumCulling: true
		};

		//

		const randomizeMatrix = function () {

			const position = new THREE.Vector3();
			const rotation = new THREE.Euler();
			const quaternion = new THREE.Quaternion();
			const scale = new THREE.Vector3();

			return function ( matrix ) {

				position.x = Math.random() * 40 - 20;
				position.y = Math.random() * 40 - 20;
				position.z = Math.random() * 40 - 20;

				rotation.x = Math.random() * 2 * Math.PI;
				rotation.y = Math.random() * 2 * Math.PI;
				rotation.z = Math.random() * 2 * Math.PI;

				quaternion.setFromEuler( rotation );

				scale.x = scale.y = scale.z = 0.5 + ( Math.random() * 0.5 );

				return matrix.compose( position, quaternion, scale );

			};

		}();

		const randomizeRotationSpeed = ( rotation ) => {

			rotation.x = Math.random() * 0.01;
			rotation.y = Math.random() * 0.01;
			rotation.z = Math.random() * 0.01;
			return rotation;

		};

		const initGeometries = () => {

			geometries = [
				new THREE.ConeBufferGeometry( 1.0, 2.0 ),
				new THREE.BoxBufferGeometry( 2.0, 2.0, 2.0 ),
				new THREE.SphereBufferGeometry( 1.0 ),
			];

		};

		const createMaterial = () => {

			return new THREE.MeshNormalMaterial();

		};

		const cleanup = () => {

			if ( mesh ) {

				mesh.parent.remove( mesh );

				if ( mesh.dispose ) {

					mesh.dispose();

				}

			}

		};

		const initMesh = () => {

			cleanup();

			if ( api.method === Method.BATCHED ) {

				initBatchedMesh();

			} else {

				initRegularMesh();

			}

		};

		const initRegularMesh = () => {

			const matrix = new THREE.Matrix4();
			mesh = new THREE.Group();
			mesh.frustumCulled = api.frustumCulling;

			for ( let i = 0; i < api.count; i ++ ) {

				const child = new THREE.Mesh( geometries[ i % geometries.length ], createMaterial() );
				randomizeMatrix( child.matrix );
				child.matrix.decompose( child.position, child.quaternion, child.scale );
				child.userData.rotationSpeed = randomizeRotationSpeed( new THREE.Euler() );
				mesh.add( child );

			}

			scene.add( mesh );

		};

		const initBatchedMesh = () => {

			const geometryCount = api.count;
			const vertexCount = api.count * 512;
			const indexCount = api.count * 1024;

			const matrix = new THREE.Matrix4();
			mesh = new THREE.BatchedMesh( createMaterial(), geometryCount, vertexCount, indexCount );
			mesh.userData.rotationSpeeds = [];

			for ( let i = 0; i < api.count; i ++ ) {

				const id = mesh.applyGeometry( geometries[ i % geometries.length ] );
				mesh.setMatrixAt( id, randomizeMatrix( matrix ) );
				mesh.userData.rotationSpeeds.push( randomizeRotationSpeed( new THREE.Euler() ) );
				mesh.frustumCulled = api.frustumCulling;

			}

			scene.add( mesh );

		};

		const updateFrustumCulling = () => {

			if ( ! mesh ) return;

			if ( api.method === Method.BATCHED ) {

				mesh.frustumCulled = api.frustumCulling;

			} else {

				for ( const child of mesh.children ) {

					child.frustumCulled = api.frustumCulling;

				}

			}

		};

		const init = () => {

			const width = window.innerWidth;
			const height = window.innerHeight;

			// camera

			camera = new THREE.PerspectiveCamera( 70, width / height, 1, 100 );
			camera.position.z = 30;

			// renderer

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( width, height );
			renderer.outputEncoding = THREE.sRGBEncoding;

			container = document.getElementById( 'container' );
			container.appendChild( renderer.domElement );

			// scene

			scene = new THREE.Scene();
			scene.background = new THREE.Color( 0xffffff );

			// controls

			controls = new OrbitControls( camera, renderer.domElement );
			controls.autoRotate = true;
			controls.autoRotateSpeed = 1.0;

			// stats

			stats = new Stats();
			container.appendChild( stats.dom );

			// gui

			gui = new GUI();
			gui.add( api, 'count', 1, MAX_GEOMETRY_COUNT ).step( 1 ).onChange( initMesh );
			gui.add( api, 'method', Method ).onChange( initMesh );
			gui.add( api, 'frustumCulling' ).onChange( updateFrustumCulling );

			guiStatsEl = document.createElement( 'li' );
			guiStatsEl.classList.add( 'gui-stats' );

			// listeners

			window.addEventListener( 'resize', onWindowResize );

			Object.assign( window, { scene } );

		};

		//

		const onWindowResize = () => {

			const width = window.innerWidth;
			const height = window.innerHeight;

			camera.aspect = width / height;
			camera.updateProjectionMatrix();

			renderer.setSize( width, height );

		};

		const animate = () => {

			requestAnimationFrame( animate );

			animateMeshes();

			controls.update();
			stats.update();

			render();

		};

		const animateMeshes = function () {

			const matrix = new THREE.Matrix4();
			const position = new THREE.Vector3();
			const rotation = new THREE.Euler();
			const quaternion = new THREE.Quaternion();
			const scale = new THREE.Vector3();

			return function () {

				if ( api.method === Method.BATCHED ) {

					for ( let i = 0; i < api.count; i ++ ) {

						const rotationSpeed = mesh.userData.rotationSpeeds[ i ];

						mesh.getMatrixAt( i, matrix );
						matrix.decompose( position, quaternion, scale );
						rotation.setFromQuaternion( quaternion );
						rotation.x += rotationSpeed.x;
						rotation.y += rotationSpeed.y;
						rotation.z += rotationSpeed.z;
						quaternion.setFromEuler( rotation );
						matrix.compose( position, quaternion, scale );
						mesh.setMatrixAt( i, matrix );

					}

				} else {

					for ( let i = 0; i < api.count; i ++ ) {

						const child = mesh.children[ i ];
						const rotationSpeed = child.userData.rotationSpeed;

						child.rotation.set(
							child.rotation.x + rotationSpeed.x,
							child.rotation.y + rotationSpeed.y,
							child.rotation.z + rotationSpeed.z
						);

					}

				}

			};

		}();

		const render = () => {

			renderer.render( scene, camera );

		};

		//

		init();
		initGeometries();
		initMesh();
		animate();

	</script>

</body>
</html>
